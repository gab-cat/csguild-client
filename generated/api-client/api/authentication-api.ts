// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * NestJS Authentication API
 * A comprehensive NestJS authentication API with PostgreSQL & Prisma.  ### Features - JWT Authentication with Access & Refresh tokens - Google OAuth2 integration - Local authentication (email/password) - Cookie-based token storage - Protected routes with guards  ### Authentication This API uses JWT tokens stored in HTTP-only cookies for authentication.  1. Local Authentication 2. Google OAuth
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AuthControllerForgotPassword200Response } from '../models';
// @ts-ignore
import { AuthControllerResetPassword200Response } from '../models';
// @ts-ignore
import { AuthErrorResponseDto } from '../models';
// @ts-ignore
import { AuthSuccessResponseDto } from '../models';
// @ts-ignore
import { ForgotPasswordDto } from '../models';
// @ts-ignore
import { LoginDto } from '../models';
// @ts-ignore
import { ResetPasswordDto } from '../models';
// @ts-ignore
import { RfidLoginDto } from '../models';
// @ts-ignore
import { UserResponseDto } from '../models';
/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *        Initiates a password reset flow by sending a reset token via email.              ## How it works:       1. Validates that the email exists in the system       2. Generates a secure random token (32 bytes, hex encoded)       3. Hashes the token before storing in database       4. Sets expiration time (1 hour from request)       5. Sends email with unhashed token to user       6. Returns success response regardless of email existence (security)              ## Security Features:       - Tokens are securely hashed in database       - 1-hour expiration time       - Rate limiting recommended (implement separately)       - No information leakage about email existence       - Old tokens are overwritten              ## Email Content:       - Reset code for manual entry       - Direct link to reset password page       - Clear expiration information       - Security warnings and instructions     
         * @summary Request password reset
         * @param {ForgotPasswordDto} forgotPasswordDto Password reset request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgotPassword: async (forgotPasswordDto: ForgotPasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgotPasswordDto' is not null or undefined
            assertParamExists('authControllerForgotPassword', 'forgotPasswordDto', forgotPasswordDto)
            const localVarPath = `/api/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgotPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Handles the callback from Google OAuth flow.              ## How it works:       1. Receives authorization code from Google       2. Exchanges code for user profile information       3. Creates or finds existing user account       4. Auto-verifies email for Google accounts       5. Generates JWT tokens and sets cookies       6. Redirects to configured frontend URL              ## Auto-Account Creation:       - Email and profile information from Google       - Auto-generated username if not provided       - Email is automatically verified       - Default STUDENT role assigned              ## Environment variables used:       - AUTH_UI_REDIRECT: Frontend URL to redirect after success     
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleCallback: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Authenticates student with email and password credentials.              ## How it works:       1. Checks for rate limiting (max 5 failed attempts per 15 minutes per IP)       2. Validates credentials using LocalAuthGuard (LocalStrategy)       3. Verifies that email is verified       4. Generates JWT access and refresh tokens       5. Sets HTTP-only cookies with tokens       6. Returns success response              ## Email Verification Required:       Students must verify their email address before being able to log in.       If email is not verified, the login will fail with instructions to verify.              ## Rate Limiting:       - Maximum 5 failed login attempts per IP address within 15 minutes       - After 5 failed attempts, IP is temporarily blocked for 15 minutes       - Successful login clears the failed attempt counter       - Error messages include remaining attempts and lockout duration              ## Cookies set:       - `Authentication`: JWT access token (1 hour expiry)       - `Refresh`: JWT refresh token (24 hours expiry)     
         * @summary Login with email and password
         * @param {LoginDto} loginDto User login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Initiates Google OAuth 2.0 authentication flow.              ## How it works:       1. Redirects user to Google OAuth consent screen       2. User grants permission to access profile and email       3. Google redirects back to callback URL with authorization code       4. System exchanges code for user profile information              ## OAuth Flow:       1. User clicks \"Login with Google\"       2. Redirected to this endpoint       3. Redirected to Google OAuth consent screen       4. User grants permission       5. Google redirects to /auth/google/callback       6. System creates or finds user account       7. User is logged in automatically              ## Auto-Registration:       - If user doesn\'t exist, account is created automatically       - Email is auto-verified for Google accounts       - Username is generated from email if not provided       - Default role: STUDENT     
         * @summary Initiate Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGoogle: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Logs out the current user by invalidating tokens.              ## How it works:       1. Validates current user from JWT token       2. Removes refresh token from database       3. Clears authentication cookies       4. Returns success response              ## Security:       - Refresh token is removed from database       - Cookies are cleared with immediate expiration       - Access token becomes invalid on next request     
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Refreshes the JWT access token using a valid refresh token.              ## How it works:       1. Validates refresh token from `Refresh` cookie       2. Uses JwtRefreshAuthGuard (JwtRefreshStrategy) to validate token       3. Compares refresh token with hashed version in database       4. Generates new access and refresh tokens       5. Updates refresh token in database       6. Sets new cookies with updated expiration times              ## Required cookies:       - `Refresh`: Valid JWT refresh token              ## Security:       - Refresh tokens are hashed in database       - Old refresh token is invalidated       - New tokens have updated expiration times     
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Resets user password using a valid reset token.              ## How it works:       1. Validates the reset token format and presence       2. Searches for user with matching hashed token       3. Checks token expiration (must be within 1 hour)       4. Validates new password meets requirements       5. Hashes the new password       6. Updates user password and clears reset token       7. Invalidates all refresh tokens (forces re-login)              ## Security Features:       - Token comparison uses secure hashing       - Automatic token expiration       - Password strength validation       - Session invalidation after reset       - One-time use tokens              ## Password Requirements:       - Minimum 8 characters       - Additional strength requirements recommended              ## After Reset:       - User must log in again with new password       - All existing sessions are invalidated       - Reset token is permanently deleted     
         * @summary Reset password with token
         * @param {ResetPasswordDto} resetPasswordDto Password reset with token details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword: async (resetPasswordDto: ResetPasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'resetPasswordDto' is not null or undefined
            assertParamExists('authControllerResetPassword', 'resetPasswordDto', resetPasswordDto)
            const localVarPath = `/api/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(resetPasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *        Authenticates a student using their registered RFID card and creates a session.              ## How it works:       1. Validates RFID card is registered in the system       2. Checks that associated email is verified       3. Creates JWT access and refresh tokens       4. Sets HTTP-only cookies with tokens       5. Returns student information and success response              ## RFID Login Features:       - No username/password required       - Quick authentication for terminals       - Automatic session creation       - Same security as regular login              ## Requirements:       - RFID card must be registered       - Associated email must be verified       - Valid RFID card format              ## Use Cases:       - Quick login at CSGUILD terminals       - Attendance tracking at events       - Access control for facilities       - Lab equipment authentication     
         * @summary Login using RFID card
         * @param {RfidLoginDto} rfidLoginDto RFID card login details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRfidLogin: async (rfidLoginDto: RfidLoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'rfidLoginDto' is not null or undefined
            assertParamExists('authControllerRfidLogin', 'rfidLoginDto', rfidLoginDto)
            const localVarPath = `/api/auth/rfid-login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rfidLoginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         *        Initiates a password reset flow by sending a reset token via email.              ## How it works:       1. Validates that the email exists in the system       2. Generates a secure random token (32 bytes, hex encoded)       3. Hashes the token before storing in database       4. Sets expiration time (1 hour from request)       5. Sends email with unhashed token to user       6. Returns success response regardless of email existence (security)              ## Security Features:       - Tokens are securely hashed in database       - 1-hour expiration time       - Rate limiting recommended (implement separately)       - No information leakage about email existence       - Old tokens are overwritten              ## Email Content:       - Reset code for manual entry       - Direct link to reset password page       - Clear expiration information       - Security warnings and instructions     
         * @summary Request password reset
         * @param {ForgotPasswordDto} forgotPasswordDto Password reset request details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerForgotPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerForgotPassword(forgotPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Handles the callback from Google OAuth flow.              ## How it works:       1. Receives authorization code from Google       2. Exchanges code for user profile information       3. Creates or finds existing user account       4. Auto-verifies email for Google accounts       5. Generates JWT tokens and sets cookies       6. Redirects to configured frontend URL              ## Auto-Account Creation:       - Email and profile information from Google       - Auto-generated username if not provided       - Email is automatically verified       - Default STUDENT role assigned              ## Environment variables used:       - AUTH_UI_REDIRECT: Frontend URL to redirect after success     
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerGoogleCallback(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerGoogleCallback(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Authenticates student with email and password credentials.              ## How it works:       1. Checks for rate limiting (max 5 failed attempts per 15 minutes per IP)       2. Validates credentials using LocalAuthGuard (LocalStrategy)       3. Verifies that email is verified       4. Generates JWT access and refresh tokens       5. Sets HTTP-only cookies with tokens       6. Returns success response              ## Email Verification Required:       Students must verify their email address before being able to log in.       If email is not verified, the login will fail with instructions to verify.              ## Rate Limiting:       - Maximum 5 failed login attempts per IP address within 15 minutes       - After 5 failed attempts, IP is temporarily blocked for 15 minutes       - Successful login clears the failed attempt counter       - Error messages include remaining attempts and lockout duration              ## Cookies set:       - `Authentication`: JWT access token (1 hour expiry)       - `Refresh`: JWT refresh token (24 hours expiry)     
         * @summary Login with email and password
         * @param {LoginDto} loginDto User login credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Initiates Google OAuth 2.0 authentication flow.              ## How it works:       1. Redirects user to Google OAuth consent screen       2. User grants permission to access profile and email       3. Google redirects back to callback URL with authorization code       4. System exchanges code for user profile information              ## OAuth Flow:       1. User clicks \"Login with Google\"       2. Redirected to this endpoint       3. Redirected to Google OAuth consent screen       4. User grants permission       5. Google redirects to /auth/google/callback       6. System creates or finds user account       7. User is logged in automatically              ## Auto-Registration:       - If user doesn\'t exist, account is created automatically       - Email is auto-verified for Google accounts       - Username is generated from email if not provided       - Default role: STUDENT     
         * @summary Initiate Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLoginGoogle(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLoginGoogle(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Logs out the current user by invalidating tokens.              ## How it works:       1. Validates current user from JWT token       2. Removes refresh token from database       3. Clears authentication cookies       4. Returns success response              ## Security:       - Refresh token is removed from database       - Cookies are cleared with immediate expiration       - Access token becomes invalid on next request     
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerMe(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerMe(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Refreshes the JWT access token using a valid refresh token.              ## How it works:       1. Validates refresh token from `Refresh` cookie       2. Uses JwtRefreshAuthGuard (JwtRefreshStrategy) to validate token       3. Compares refresh token with hashed version in database       4. Generates new access and refresh tokens       5. Updates refresh token in database       6. Sets new cookies with updated expiration times              ## Required cookies:       - `Refresh`: Valid JWT refresh token              ## Security:       - Refresh tokens are hashed in database       - Old refresh token is invalidated       - New tokens have updated expiration times     
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRefresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRefresh(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Resets user password using a valid reset token.              ## How it works:       1. Validates the reset token format and presence       2. Searches for user with matching hashed token       3. Checks token expiration (must be within 1 hour)       4. Validates new password meets requirements       5. Hashes the new password       6. Updates user password and clears reset token       7. Invalidates all refresh tokens (forces re-login)              ## Security Features:       - Token comparison uses secure hashing       - Automatic token expiration       - Password strength validation       - Session invalidation after reset       - One-time use tokens              ## Password Requirements:       - Minimum 8 characters       - Additional strength requirements recommended              ## After Reset:       - User must log in again with new password       - All existing sessions are invalidated       - Reset token is permanently deleted     
         * @summary Reset password with token
         * @param {ResetPasswordDto} resetPasswordDto Password reset with token details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthControllerResetPassword200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerResetPassword(resetPasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *        Authenticates a student using their registered RFID card and creates a session.              ## How it works:       1. Validates RFID card is registered in the system       2. Checks that associated email is verified       3. Creates JWT access and refresh tokens       4. Sets HTTP-only cookies with tokens       5. Returns student information and success response              ## RFID Login Features:       - No username/password required       - Quick authentication for terminals       - Automatic session creation       - Same security as regular login              ## Requirements:       - RFID card must be registered       - Associated email must be verified       - Valid RFID card format              ## Use Cases:       - Quick login at CSGUILD terminals       - Attendance tracking at events       - Access control for facilities       - Lab equipment authentication     
         * @summary Login using RFID card
         * @param {RfidLoginDto} rfidLoginDto RFID card login details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRfidLogin(rfidLoginDto: RfidLoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSuccessResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRfidLogin(rfidLoginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         *        Initiates a password reset flow by sending a reset token via email.              ## How it works:       1. Validates that the email exists in the system       2. Generates a secure random token (32 bytes, hex encoded)       3. Hashes the token before storing in database       4. Sets expiration time (1 hour from request)       5. Sends email with unhashed token to user       6. Returns success response regardless of email existence (security)              ## Security Features:       - Tokens are securely hashed in database       - 1-hour expiration time       - Rate limiting recommended (implement separately)       - No information leakage about email existence       - Old tokens are overwritten              ## Email Content:       - Reset code for manual entry       - Direct link to reset password page       - Clear expiration information       - Security warnings and instructions     
         * @summary Request password reset
         * @param {AuthenticationApiAuthControllerForgotPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerForgotPassword(requestParameters: AuthenticationApiAuthControllerForgotPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<AuthControllerForgotPassword200Response> {
            return localVarFp.authControllerForgotPassword(requestParameters.forgotPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         *        Handles the callback from Google OAuth flow.              ## How it works:       1. Receives authorization code from Google       2. Exchanges code for user profile information       3. Creates or finds existing user account       4. Auto-verifies email for Google accounts       5. Generates JWT tokens and sets cookies       6. Redirects to configured frontend URL              ## Auto-Account Creation:       - Email and profile information from Google       - Auto-generated username if not provided       - Email is automatically verified       - Default STUDENT role assigned              ## Environment variables used:       - AUTH_UI_REDIRECT: Frontend URL to redirect after success     
         * @summary Google OAuth callback
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerGoogleCallback(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerGoogleCallback(options).then((request) => request(axios, basePath));
        },
        /**
         *        Authenticates student with email and password credentials.              ## How it works:       1. Checks for rate limiting (max 5 failed attempts per 15 minutes per IP)       2. Validates credentials using LocalAuthGuard (LocalStrategy)       3. Verifies that email is verified       4. Generates JWT access and refresh tokens       5. Sets HTTP-only cookies with tokens       6. Returns success response              ## Email Verification Required:       Students must verify their email address before being able to log in.       If email is not verified, the login will fail with instructions to verify.              ## Rate Limiting:       - Maximum 5 failed login attempts per IP address within 15 minutes       - After 5 failed attempts, IP is temporarily blocked for 15 minutes       - Successful login clears the failed attempt counter       - Error messages include remaining attempts and lockout duration              ## Cookies set:       - `Authentication`: JWT access token (1 hour expiry)       - `Refresh`: JWT refresh token (24 hours expiry)     
         * @summary Login with email and password
         * @param {AuthenticationApiAuthControllerLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(requestParameters: AuthenticationApiAuthControllerLoginRequest, options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto> {
            return localVarFp.authControllerLogin(requestParameters.loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         *        Initiates Google OAuth 2.0 authentication flow.              ## How it works:       1. Redirects user to Google OAuth consent screen       2. User grants permission to access profile and email       3. Google redirects back to callback URL with authorization code       4. System exchanges code for user profile information              ## OAuth Flow:       1. User clicks \"Login with Google\"       2. Redirected to this endpoint       3. Redirected to Google OAuth consent screen       4. User grants permission       5. Google redirects to /auth/google/callback       6. System creates or finds user account       7. User is logged in automatically              ## Auto-Registration:       - If user doesn\'t exist, account is created automatically       - Email is auto-verified for Google accounts       - Username is generated from email if not provided       - Default role: STUDENT     
         * @summary Initiate Google OAuth login
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLoginGoogle(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authControllerLoginGoogle(options).then((request) => request(axios, basePath));
        },
        /**
         *        Logs out the current user by invalidating tokens.              ## How it works:       1. Validates current user from JWT token       2. Removes refresh token from database       3. Clears authentication cookies       4. Returns success response              ## Security:       - Refresh token is removed from database       - Cookies are cleared with immediate expiration       - Access token becomes invalid on next request     
         * @summary Logout user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogout(options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto> {
            return localVarFp.authControllerLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current user
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerMe(options?: AxiosRequestConfig): AxiosPromise<UserResponseDto> {
            return localVarFp.authControllerMe(options).then((request) => request(axios, basePath));
        },
        /**
         *        Refreshes the JWT access token using a valid refresh token.              ## How it works:       1. Validates refresh token from `Refresh` cookie       2. Uses JwtRefreshAuthGuard (JwtRefreshStrategy) to validate token       3. Compares refresh token with hashed version in database       4. Generates new access and refresh tokens       5. Updates refresh token in database       6. Sets new cookies with updated expiration times              ## Required cookies:       - `Refresh`: Valid JWT refresh token              ## Security:       - Refresh tokens are hashed in database       - Old refresh token is invalidated       - New tokens have updated expiration times     
         * @summary Refresh access token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRefresh(options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto> {
            return localVarFp.authControllerRefresh(options).then((request) => request(axios, basePath));
        },
        /**
         *        Resets user password using a valid reset token.              ## How it works:       1. Validates the reset token format and presence       2. Searches for user with matching hashed token       3. Checks token expiration (must be within 1 hour)       4. Validates new password meets requirements       5. Hashes the new password       6. Updates user password and clears reset token       7. Invalidates all refresh tokens (forces re-login)              ## Security Features:       - Token comparison uses secure hashing       - Automatic token expiration       - Password strength validation       - Session invalidation after reset       - One-time use tokens              ## Password Requirements:       - Minimum 8 characters       - Additional strength requirements recommended              ## After Reset:       - User must log in again with new password       - All existing sessions are invalidated       - Reset token is permanently deleted     
         * @summary Reset password with token
         * @param {AuthenticationApiAuthControllerResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerResetPassword(requestParameters: AuthenticationApiAuthControllerResetPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<AuthControllerResetPassword200Response> {
            return localVarFp.authControllerResetPassword(requestParameters.resetPasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         *        Authenticates a student using their registered RFID card and creates a session.              ## How it works:       1. Validates RFID card is registered in the system       2. Checks that associated email is verified       3. Creates JWT access and refresh tokens       4. Sets HTTP-only cookies with tokens       5. Returns student information and success response              ## RFID Login Features:       - No username/password required       - Quick authentication for terminals       - Automatic session creation       - Same security as regular login              ## Requirements:       - RFID card must be registered       - Associated email must be verified       - Valid RFID card format              ## Use Cases:       - Quick login at CSGUILD terminals       - Attendance tracking at events       - Access control for facilities       - Lab equipment authentication     
         * @summary Login using RFID card
         * @param {AuthenticationApiAuthControllerRfidLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRfidLogin(requestParameters: AuthenticationApiAuthControllerRfidLoginRequest, options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto> {
            return localVarFp.authControllerRfidLogin(requestParameters.rfidLoginDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     *        Initiates a password reset flow by sending a reset token via email.              ## How it works:       1. Validates that the email exists in the system       2. Generates a secure random token (32 bytes, hex encoded)       3. Hashes the token before storing in database       4. Sets expiration time (1 hour from request)       5. Sends email with unhashed token to user       6. Returns success response regardless of email existence (security)              ## Security Features:       - Tokens are securely hashed in database       - 1-hour expiration time       - Rate limiting recommended (implement separately)       - No information leakage about email existence       - Old tokens are overwritten              ## Email Content:       - Reset code for manual entry       - Direct link to reset password page       - Clear expiration information       - Security warnings and instructions     
     * @summary Request password reset
     * @param {ForgotPasswordDto} forgotPasswordDto Password reset request details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerForgotPassword(forgotPasswordDto: ForgotPasswordDto, options?: AxiosRequestConfig): AxiosPromise<AuthControllerForgotPassword200Response>;

    /**
     *        Handles the callback from Google OAuth flow.              ## How it works:       1. Receives authorization code from Google       2. Exchanges code for user profile information       3. Creates or finds existing user account       4. Auto-verifies email for Google accounts       5. Generates JWT tokens and sets cookies       6. Redirects to configured frontend URL              ## Auto-Account Creation:       - Email and profile information from Google       - Auto-generated username if not provided       - Email is automatically verified       - Default STUDENT role assigned              ## Environment variables used:       - AUTH_UI_REDIRECT: Frontend URL to redirect after success     
     * @summary Google OAuth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerGoogleCallback(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     *        Authenticates student with email and password credentials.              ## How it works:       1. Checks for rate limiting (max 5 failed attempts per 15 minutes per IP)       2. Validates credentials using LocalAuthGuard (LocalStrategy)       3. Verifies that email is verified       4. Generates JWT access and refresh tokens       5. Sets HTTP-only cookies with tokens       6. Returns success response              ## Email Verification Required:       Students must verify their email address before being able to log in.       If email is not verified, the login will fail with instructions to verify.              ## Rate Limiting:       - Maximum 5 failed login attempts per IP address within 15 minutes       - After 5 failed attempts, IP is temporarily blocked for 15 minutes       - Successful login clears the failed attempt counter       - Error messages include remaining attempts and lockout duration              ## Cookies set:       - `Authentication`: JWT access token (1 hour expiry)       - `Refresh`: JWT refresh token (24 hours expiry)     
     * @summary Login with email and password
     * @param {LoginDto} loginDto User login credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto>;

    /**
     *        Initiates Google OAuth 2.0 authentication flow.              ## How it works:       1. Redirects user to Google OAuth consent screen       2. User grants permission to access profile and email       3. Google redirects back to callback URL with authorization code       4. System exchanges code for user profile information              ## OAuth Flow:       1. User clicks \"Login with Google\"       2. Redirected to this endpoint       3. Redirected to Google OAuth consent screen       4. User grants permission       5. Google redirects to /auth/google/callback       6. System creates or finds user account       7. User is logged in automatically              ## Auto-Registration:       - If user doesn\'t exist, account is created automatically       - Email is auto-verified for Google accounts       - Username is generated from email if not provided       - Default role: STUDENT     
     * @summary Initiate Google OAuth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerLoginGoogle(options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     *        Logs out the current user by invalidating tokens.              ## How it works:       1. Validates current user from JWT token       2. Removes refresh token from database       3. Clears authentication cookies       4. Returns success response              ## Security:       - Refresh token is removed from database       - Cookies are cleared with immediate expiration       - Access token becomes invalid on next request     
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerLogout(options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto>;

    /**
     * Returns the current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerMe(options?: AxiosRequestConfig): AxiosPromise<UserResponseDto>;

    /**
     *        Refreshes the JWT access token using a valid refresh token.              ## How it works:       1. Validates refresh token from `Refresh` cookie       2. Uses JwtRefreshAuthGuard (JwtRefreshStrategy) to validate token       3. Compares refresh token with hashed version in database       4. Generates new access and refresh tokens       5. Updates refresh token in database       6. Sets new cookies with updated expiration times              ## Required cookies:       - `Refresh`: Valid JWT refresh token              ## Security:       - Refresh tokens are hashed in database       - Old refresh token is invalidated       - New tokens have updated expiration times     
     * @summary Refresh access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerRefresh(options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto>;

    /**
     *        Resets user password using a valid reset token.              ## How it works:       1. Validates the reset token format and presence       2. Searches for user with matching hashed token       3. Checks token expiration (must be within 1 hour)       4. Validates new password meets requirements       5. Hashes the new password       6. Updates user password and clears reset token       7. Invalidates all refresh tokens (forces re-login)              ## Security Features:       - Token comparison uses secure hashing       - Automatic token expiration       - Password strength validation       - Session invalidation after reset       - One-time use tokens              ## Password Requirements:       - Minimum 8 characters       - Additional strength requirements recommended              ## After Reset:       - User must log in again with new password       - All existing sessions are invalidated       - Reset token is permanently deleted     
     * @summary Reset password with token
     * @param {ResetPasswordDto} resetPasswordDto Password reset with token details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerResetPassword(resetPasswordDto: ResetPasswordDto, options?: AxiosRequestConfig): AxiosPromise<AuthControllerResetPassword200Response>;

    /**
     *        Authenticates a student using their registered RFID card and creates a session.              ## How it works:       1. Validates RFID card is registered in the system       2. Checks that associated email is verified       3. Creates JWT access and refresh tokens       4. Sets HTTP-only cookies with tokens       5. Returns student information and success response              ## RFID Login Features:       - No username/password required       - Quick authentication for terminals       - Automatic session creation       - Same security as regular login              ## Requirements:       - RFID card must be registered       - Associated email must be verified       - Valid RFID card format              ## Use Cases:       - Quick login at CSGUILD terminals       - Attendance tracking at events       - Access control for facilities       - Lab equipment authentication     
     * @summary Login using RFID card
     * @param {RfidLoginDto} rfidLoginDto RFID card login details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    authControllerRfidLogin(rfidLoginDto: RfidLoginDto, options?: AxiosRequestConfig): AxiosPromise<AuthSuccessResponseDto>;

}

/**
 * Request parameters for authControllerForgotPassword operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiAuthControllerForgotPasswordRequest
 */
export interface AuthenticationApiAuthControllerForgotPasswordRequest {
    /**
     * Password reset request details
     * @type {ForgotPasswordDto}
     * @memberof AuthenticationApiAuthControllerForgotPassword
     */
    readonly forgotPasswordDto: ForgotPasswordDto
}

/**
 * Request parameters for authControllerLogin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiAuthControllerLoginRequest
 */
export interface AuthenticationApiAuthControllerLoginRequest {
    /**
     * User login credentials
     * @type {LoginDto}
     * @memberof AuthenticationApiAuthControllerLogin
     */
    readonly loginDto: LoginDto
}

/**
 * Request parameters for authControllerResetPassword operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiAuthControllerResetPasswordRequest
 */
export interface AuthenticationApiAuthControllerResetPasswordRequest {
    /**
     * Password reset with token details
     * @type {ResetPasswordDto}
     * @memberof AuthenticationApiAuthControllerResetPassword
     */
    readonly resetPasswordDto: ResetPasswordDto
}

/**
 * Request parameters for authControllerRfidLogin operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiAuthControllerRfidLoginRequest
 */
export interface AuthenticationApiAuthControllerRfidLoginRequest {
    /**
     * RFID card login details
     * @type {RfidLoginDto}
     * @memberof AuthenticationApiAuthControllerRfidLogin
     */
    readonly rfidLoginDto: RfidLoginDto
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     *        Initiates a password reset flow by sending a reset token via email.              ## How it works:       1. Validates that the email exists in the system       2. Generates a secure random token (32 bytes, hex encoded)       3. Hashes the token before storing in database       4. Sets expiration time (1 hour from request)       5. Sends email with unhashed token to user       6. Returns success response regardless of email existence (security)              ## Security Features:       - Tokens are securely hashed in database       - 1-hour expiration time       - Rate limiting recommended (implement separately)       - No information leakage about email existence       - Old tokens are overwritten              ## Email Content:       - Reset code for manual entry       - Direct link to reset password page       - Clear expiration information       - Security warnings and instructions     
     * @summary Request password reset
     * @param {AuthenticationApiAuthControllerForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerForgotPassword(requestParameters: AuthenticationApiAuthControllerForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerForgotPassword(requestParameters.forgotPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Handles the callback from Google OAuth flow.              ## How it works:       1. Receives authorization code from Google       2. Exchanges code for user profile information       3. Creates or finds existing user account       4. Auto-verifies email for Google accounts       5. Generates JWT tokens and sets cookies       6. Redirects to configured frontend URL              ## Auto-Account Creation:       - Email and profile information from Google       - Auto-generated username if not provided       - Email is automatically verified       - Default STUDENT role assigned              ## Environment variables used:       - AUTH_UI_REDIRECT: Frontend URL to redirect after success     
     * @summary Google OAuth callback
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerGoogleCallback(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerGoogleCallback(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Authenticates student with email and password credentials.              ## How it works:       1. Checks for rate limiting (max 5 failed attempts per 15 minutes per IP)       2. Validates credentials using LocalAuthGuard (LocalStrategy)       3. Verifies that email is verified       4. Generates JWT access and refresh tokens       5. Sets HTTP-only cookies with tokens       6. Returns success response              ## Email Verification Required:       Students must verify their email address before being able to log in.       If email is not verified, the login will fail with instructions to verify.              ## Rate Limiting:       - Maximum 5 failed login attempts per IP address within 15 minutes       - After 5 failed attempts, IP is temporarily blocked for 15 minutes       - Successful login clears the failed attempt counter       - Error messages include remaining attempts and lockout duration              ## Cookies set:       - `Authentication`: JWT access token (1 hour expiry)       - `Refresh`: JWT refresh token (24 hours expiry)     
     * @summary Login with email and password
     * @param {AuthenticationApiAuthControllerLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogin(requestParameters: AuthenticationApiAuthControllerLoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogin(requestParameters.loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Initiates Google OAuth 2.0 authentication flow.              ## How it works:       1. Redirects user to Google OAuth consent screen       2. User grants permission to access profile and email       3. Google redirects back to callback URL with authorization code       4. System exchanges code for user profile information              ## OAuth Flow:       1. User clicks \"Login with Google\"       2. Redirected to this endpoint       3. Redirected to Google OAuth consent screen       4. User grants permission       5. Google redirects to /auth/google/callback       6. System creates or finds user account       7. User is logged in automatically              ## Auto-Registration:       - If user doesn\'t exist, account is created automatically       - Email is auto-verified for Google accounts       - Username is generated from email if not provided       - Default role: STUDENT     
     * @summary Initiate Google OAuth login
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLoginGoogle(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLoginGoogle(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Logs out the current user by invalidating tokens.              ## How it works:       1. Validates current user from JWT token       2. Removes refresh token from database       3. Clears authentication cookies       4. Returns success response              ## Security:       - Refresh token is removed from database       - Cookies are cleared with immediate expiration       - Access token becomes invalid on next request     
     * @summary Logout user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerLogout(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current user
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerMe(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerMe(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Refreshes the JWT access token using a valid refresh token.              ## How it works:       1. Validates refresh token from `Refresh` cookie       2. Uses JwtRefreshAuthGuard (JwtRefreshStrategy) to validate token       3. Compares refresh token with hashed version in database       4. Generates new access and refresh tokens       5. Updates refresh token in database       6. Sets new cookies with updated expiration times              ## Required cookies:       - `Refresh`: Valid JWT refresh token              ## Security:       - Refresh tokens are hashed in database       - Old refresh token is invalidated       - New tokens have updated expiration times     
     * @summary Refresh access token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerRefresh(options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRefresh(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Resets user password using a valid reset token.              ## How it works:       1. Validates the reset token format and presence       2. Searches for user with matching hashed token       3. Checks token expiration (must be within 1 hour)       4. Validates new password meets requirements       5. Hashes the new password       6. Updates user password and clears reset token       7. Invalidates all refresh tokens (forces re-login)              ## Security Features:       - Token comparison uses secure hashing       - Automatic token expiration       - Password strength validation       - Session invalidation after reset       - One-time use tokens              ## Password Requirements:       - Minimum 8 characters       - Additional strength requirements recommended              ## After Reset:       - User must log in again with new password       - All existing sessions are invalidated       - Reset token is permanently deleted     
     * @summary Reset password with token
     * @param {AuthenticationApiAuthControllerResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerResetPassword(requestParameters: AuthenticationApiAuthControllerResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerResetPassword(requestParameters.resetPasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *        Authenticates a student using their registered RFID card and creates a session.              ## How it works:       1. Validates RFID card is registered in the system       2. Checks that associated email is verified       3. Creates JWT access and refresh tokens       4. Sets HTTP-only cookies with tokens       5. Returns student information and success response              ## RFID Login Features:       - No username/password required       - Quick authentication for terminals       - Automatic session creation       - Same security as regular login              ## Requirements:       - RFID card must be registered       - Associated email must be verified       - Valid RFID card format              ## Use Cases:       - Quick login at CSGUILD terminals       - Attendance tracking at events       - Access control for facilities       - Lab equipment authentication     
     * @summary Login using RFID card
     * @param {AuthenticationApiAuthControllerRfidLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authControllerRfidLogin(requestParameters: AuthenticationApiAuthControllerRfidLoginRequest, options?: AxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authControllerRfidLogin(requestParameters.rfidLoginDto, options).then((request) => request(this.axios, this.basePath));
    }
}
